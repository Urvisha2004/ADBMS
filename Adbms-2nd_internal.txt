U3 - P3 ------------------ latch contention -----------------
			**- LRU latch, Library Cache latch, Redo latch, Cache Buffer Chains, and Library Cache namespaces — these are the main sources of contention.**




A)  LRU Chain Latch Contention Query            -------LRU latch buffer cache ko manage karta hai.

 								     --	-----Jab Oracle purane blocks ko nikal kar naye blocks load karta hai → LRU chain latch use hoti hai.

SELECT
    name,
    gets,
    misses,
    sleeps,
    ROUND(((gets - misses) / NULLIF(gets, 0)) * 100, 2) AS hit_ratio_percent
FROM
    v$latch
WHERE
    name LIKE '%lru%';



B)  Library Cache Latch Contention                     ------Library cache latch SQL parsing aur shared pool ke objects ko control karta hai.

SELECT
    name,
    gets,
    misses,
    sleeps,
    ROUND(((gets - misses) / NULLIF(gets, 0)) * 100, 2) AS hit_ratio_percent
FROM
    v$latch
WHERE
    name LIKE 'library cache%';


C)  Redo Latch Contention                                      ------Redo allocation latch + redo copy latch

 									------High contention tab hoti hai jab:

 									------High DML load (INSERT/UPDATE/DELETE)

SELECT
    name,
    gets,
    misses,
    sleeps,
    ROUND(((gets - misses) / NULLIF(gets, 0)) * 100, 2) AS hit_ratio_percent
FROM
    v$latch
WHERE
    name LIKE '%redo%'
ORDER BY
    hit_ratio_percent DESC;


D)  Cache Buffer Chains (CBC) Latch
 									-------High CBC latch contention = hot blocks.

 									-------Mostly tab hota hai:

 										-------Same table pe heavy concurrent access

 										-------Index root block heavily used

SELECT name, gets, misses, sleeps, spin_gets
FROM v$latch
WHERE name LIKE '%chain%';



E)  Library Cache Namespaces
 									--------Namespace = SQL AREA, TABLE/PROCEDURE, BODY, TRIGGER, etc.

 									--------Low gethits = more hard parsing = contention

 									--------pins measure execution pressure

SELECT namespace, gets, gethits, pins
FROM v$librarycache;




F)   Overall Latch Summary (Top Misses)		------- Zyada misses = zyada contention.


SELECT
    name,
    gets,
    misses,
    sleeps
FROM
    v$latch
ORDER BY
    misses DESC;






U3 -P4 -----------------------DATA BUFFER CACHE HIT RATIO
====================================================================================
(PER SESSION)
 		[QUERY NO-1]
---
SELECT
    ROUND(
        ((cur.value + con.value) / NULLIF((cur.value + con.value) - phy.value, 0)) * 100,
        2
    ) AS "Buffer Cache Hit Ratio (%)"
FROM
    v$sysstat cur,
    v$sysstat con,
    v$sysstat phy
WHERE
    cur.name = 'db block gets'
    AND con.name = 'consistent gets'
    AND phy.name = 'physical reads';
=====================================================
 		[QUERY NO-2]
======================================================
SELECT
    ROUND(
        (1 - (phy.value / (cur.value + con.value))) * 100,
        2
    ) AS "Buffer Cache Hit Ratio (%)"
FROM
    v$sysstat cur,
    v$sysstat con,
    v$sysstat phy
WHERE
    cur.name = 'db block gets'
    AND con.name = 'consistent gets'
    AND phy.name = 'physical reads';

---
(per BUFFER POOL)
---
SELECT
    name AS buffer_pool,
    db_block_gets,
    consistent_gets,
    physical_reads,
    ROUND(
        ((db_block_gets + consistent_gets - physical_reads) /
         DECODE((db_block_gets + consistent_gets),0,1,(db_block_gets + consistent_gets))) * 100,
        2
    ) AS "Buffer Cache Hit Ratio (%)"
FROM v$buffer_pool_statistics
ORDER BY name;

===================================================================================
(SYSTEM HIT RATIO)
====================================================================================
SELECT (1 - (phy.value / (cur.value + con.value))) * 100 AS "Buffer Cache Hit Ratio"
FROM v$sysstat cur, v$sysstat con, v$sysstat phy
WHERE cur.name = 'db block gets'
AND con.name = 'consistent gets'
AND phy.name = 'physical reads';
====================================================================================
(HOW IT WILL WORK)
====================================================================================
When a SQL query needs a data block:
 	Oracle first checks buffer cache (in memory).
 	If found → cache hit
 	If not found → disk read (physical read).
-===================================================================================
DB Block Gets = 1000
Consistent Gets = 500
Physical Reads = 50

Buffer Cache Hit Ratio (%) = (1 - (Physical Reads) / (DB Block Gets + Consistent Gets)) * 100

Buffer Cache Hit Ratio (%) = (1 - (50 / (1000 + 500))) * 100 = 96.7%

========================================================================================
CONCLUSION
---
Hit Ratio 90–99% → Most of the time, Oracle finds the data it needs in memory (buffer cache). This is good and fast.

Hit Ratio below 90% → Oracle has to read from the disk more often, which is slower. You might need to:

 	-Give more memory to the buffer cache (DB_CACHE_SIZE).

 	-Optimize your queries or indexes so Oracle doesn’t read unnecessary data.
======================================================================================================

higher hit ratio = faster performance
lower hit ratio = slower performance.
=========================================================================================
[Solution]
Give more memory to the buffer cache (DB_CACHE_SIZE) so frequently used data stays in memory.
Optimize queries and use indexes to reduce unnecessary disk reads.
Focus on hot tables to keep their blocks in memory for faster performance




U3 - P5 --------------	HIt ratio of shared Pool area and Redo log


SHARED POOL HIT RATIO
==========================================================================================================================
SELECT
    ROUND((SUM(gethits) / SUM(gets)) * 100, 2) AS "Shared Pool Get Hit Ratio (%)",
    ROUND((SUM(pinhits) / SUM(pins)) * 100, 2) AS "Shared Pool Pin Hit Ratio (%)"
FROM v$librarycache;

---
SELECT
    ROUND((SUM(requests) - SUM(request_misses)) / SUM(requests) * 100, 2)
        AS "Shared Pool Hit Ratio (%)"
FROM v$shared_pool_reserved;


=============================================================================================================================
                                         REDO LOG HIT RATIO
===========================================================================================================================
SELECT
    ROUND(
        (SUM(value) - SUM(CASE WHEN name = 'redo buffer allocation retries' THEN value END))
        / SUM(value) * 100,
        2
    ) AS "Redo Log Hit Ratio (%)"
FROM v$sysstat
WHERE name IN ('redo entries', 'redo buffer allocation retries');

---
SELECT
    ROUND(
        (COUNT(*) - SUM(CASE WHEN status='ACTIVE' THEN 1 ELSE 0 END))
        / COUNT(*) * 100,
        2
    ) AS "Approx Redo Log Hit Ratio (%)"
FROM v$log;

---
[Shows how much redo is being written and if sessions are waiting for log space.]

SELECT name, value,con_id,class
FROM v$sysstat
WHERE name IN ('redo writes', 'redo log space requests', 'redo log space waits');






=====================================================================================================================
 					[HOW SHARED POOL WILL WORK]
---
It checks the Library Cache (part of Shared Pool) to see if the statement or object is already in memory.
 	If found → Cache Hit (no parsing needed)
 	If not found → Miss → Oracle has to parse or load the object again (slower).
================================================================================
[EXAMPLE]

Gets = 2000
Get Misses = 100
Pins = 500
Pin Misses = 25

Get Hit Ratio (%) = (Gets - Get Misses) / Gets * 100
Get Hit Ratio (%) = (2000 - 100) / 2000 * 100 = 95%

Pin Hit Ratio (%) = (Pins - Pin Misses) / Pins * 100
Pin Hit Ratio (%) = (500 - 25) / 500 * 100 = 95%
==========================================================================
[CONCLUSION]

Hit Ratio 90–99% → Most of the time, Oracle finds objects in memory
 	→ Fast execution.
Hit Ratio below 90% → Oracle often reparses or reloads objects
 	→ Slower execution.
==========================================================================
[HOW TO RESOLVE THIS PROBLEM]

Increase SHARED_POOL_SIZE.
Reduce unnecessary PL/SQL or SQL compilations.





=====================================================================================================================
 					HOW REDO LOG  WILL WORK
=====================================================================================================================
When Oracle makes changes (INSERT, UPDATE, DELETE), it writes redo entries to the redo log buffer in memory.
If the buffer is reused efficiently → Hit (less waiting).
If the buffer cannot keep up → Miss / Wastage (needs to write to disk immediately, slower).
================================================================================
[EXAMPLE]
Redo Entries = 10000
Redo Wastage = 200

Redo Log Hit Ratio (%) = (1 - Redo Wastage / Redo Entries) * 100
Redo Log Hit Ratio (%) = (1 - 200 / 10000) * 100 = 98%
=============================================================================
[CONCLUSION]
Hit Ratio 90–99% → Redo log buffer is sufficient
 	 → Good performance.
Hit Ratio below 90% → Frequent waits for redo writes
 	→ Slower transaction processing.
==============================================================================
[HOW TO RESOLVE]

Increase LOG_BUFFER size in Oracle:
 	ALTER SYSTEM SET log_buffer = <new_size> SCOPE=BOTH;
Avoid large single transactions that generate excessive redo at once.
Tune application to commit efficiently, not too frequently, not too rarely.








U3 - P6  --- Execution Plan of the query
 		------------EXPLAIN PLAN Oracle ko kehta hai:
 		------------"Batao, agar yeh query chalti, toh tum isko kaise execute karoge?"
 		------------Yeh query actually execute nahi hoti.
 		------------Oracle sirf execution plan generate karta hai and saves it in PLAN_TABLE.


6. Find Query Execution Plan

Query:   generate execution plan using execution plain
---
EXPLAIN PLAN
  SET STATEMENT_ID = '101' FOR
  SELECT * FROM author;
EXPLAIN PLAN
  SET STATEMENT_ID = '102' FOR
  SELECT * FROM publisher;
EXPLAIN PLAN
  SET STATEMENT_ID = '103' FOR
  SELECT * FROM emp_frag;
====================================================================

query : Display execution plan from PLAN_TABLE

SET LINESIZE 150
SET PAGESIZE 200

COLUMN id FORMAT 999 HEADING "Id"
COLUMN operation FORMAT A25 HEADING "Operation"
COLUMN name FORMAT A15 HEADING "Name"
COLUMN rows FORMAT 9999 HEADING "Rows"
COLUMN bytes FORMAT 9999 HEADING "Bytes"
COLUMN "Cost (%CPU)" FORMAT A10
COLUMN time FORMAT A10 HEADING "Time"



Then :-----

SELECT
    id,
    LPAD(' ', 2 * depth) || operation AS operation,
    NVL(object_name, ' ') AS name,
    NVL(cardinality, 0) AS "Rows",
    NVL(bytes, 0) AS bytes,
    cost || ' (0)' AS "Cost %CPU",
    '00:00:01' AS "Time"
FROM
    plan_table
WHERE
    statement_id = '101'
ORDER BY
    id;
-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=--=--=-=-=-=-=--=-=-=-
query :   View execution plan in modern format


SELECT *
FROM table(DBMS_XPLAN.DISPLAY(NULL, '101'));

SELECT *
FROM table(DBMS_XPLAN.DISPLAY(NULL, '102'));
==============================================================================

query : Quick EXPLAIN PLAN (no statement_id needed)

explain plan for select * from author where authorid=1;

COLUMN object_name FORMAT A25;
COLUMN object_owner FORMAT A15;
select object_name,object_owner,operation,id,depth from plan_table;
---

explain plan for
select * from author where authorid=1;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
---
explain plan for select * from author where authorid=1;
select plan_table_output from table(dbms_xplan.display_cursor(null,null,'basic'));




U3- P7 --------- Sort area contantion

What it means:

			-Sort operations in Oracle:
			-Oracle performs sorts in memory first.
			-If memory (sort area) is not enough, it spills to disk.
			-Sort area contention occurs when memory is insufficient → more disk sorts → slows down queries.

			DBAs want to check:
				-How many sorts are in memory vs on disk.
				-The sort area hit ratio (percentage of sorts completed in memory):
				-Sort Area Hit Ratio (%)=[sorts in memory / (sorts in memory + sorts on disk)] × 100
				
V$ views to use:
	v$sysstat → for system-wide statistics (sorts memory/disk)
	v$sesstat + v$statname → for session-level statistics


				SORT AREA CONTATTION
=============================================================================================
SELECT a.sid, 
       b.name, 
       a.value 
FROM v$sesstat a, v$statname b 
WHERE a.statistic# = b.statistic# 
AND b.name = 'sorts (memory)';
======================================================================
SELECT name, value
FROM v$sysstat
WHERE name IN ('sorts (memory)', 'sorts (disk)');
============================================================
 SELECT
       (SELECT VALUE FROM v$sysstat WHERE name = 'sorts (memory)') AS memory_sorts,
       (SELECT VALUE FROM v$sysstat WHERE name = 'sorts (disk)') AS disk_sorts
    FROM dual;
============================================================================
			SORT AREA HIT RATIO
============================================================================
SELECT
        MEM.VALUE AS sorts_in_memory,
       DISK.VALUE AS sorts_on_disk,
       ROUND(
           (MEM.VALUE / (MEM.VALUE + DISK.VALUE)) * 100,
           2
       ) AS sort_hit_ratio_percent
   FROM
       (SELECT VALUE FROM v$sysstat WHERE name = 'sorts (memory)') MEM,
      (SELECT VALUE FROM v$sysstat WHERE name = 'sorts (disk)') DISK;
============================================================
 SELECT
       ROUND(
           (MEM_SORTS.VALUE /
           (MEM_SORTS.VALUE + DISK_SORTS.VALUE)) * 100,
           2
      ) AS sort_hit_ratio_percent
    FROM
        (SELECT VALUE FROM v$sysstat WHERE name = 'sorts (memory)') MEM_SORTS,
        (SELECT VALUE FROM v$sysstat WHERE name = 'sorts (disk)') DISK_SORTS;
================================================================================
ALTER SYSTEM SET SORT_AREA_SIZE = 10M;



U4 - P1 ----------------- Dbms  space


SET SERVEROUTPUT ON
DECLARE
    l_total_blocks            NUMBER;
    l_total_bytes             NUMBER;
    l_unused_blocks           NUMBER;
    l_unused_bytes            NUMBER;
    l_last_used_extent_file_id NUMBER;
    l_last_used_extent_block_id NUMBER;
    l_last_used_block          NUMBER;
BEGIN
    DBMS_SPACE.UNUSED_SPACE (
        segment_owner             => 'MCA36',
        segment_name              => 'AUTHOR',
        segment_type              => 'TABLE',
        total_blocks              => l_total_blocks,
        total_bytes               => l_total_bytes,
        unused_blocks             => l_unused_blocks,
        unused_bytes              => l_unused_bytes,
        last_used_extent_file_id  => l_last_used_extent_file_id,
        last_used_extent_block_id => l_last_used_extent_block_id,
        last_used_block           => l_last_used_block
    );

    DBMS_OUTPUT.PUT_LINE('Total Blocks        : ' || l_total_blocks);
    DBMS_OUTPUT.PUT_LINE('Total Bytes         : ' || l_total_bytes);
    DBMS_OUTPUT.PUT_LINE('Unused Blocks       : ' || l_unused_blocks);
    DBMS_OUTPUT.PUT_LINE('Unused Bytes        : ' || l_unused_bytes);
    DBMS_OUTPUT.PUT_LINE('Last Used File ID   : ' || l_last_used_extent_file_id);
    DBMS_OUTPUT.PUT_LINE('Last Used Block ID  : ' || l_last_used_extent_block_id);
    DBMS_OUTPUT.PUT_LINE('Last Used Block     : ' || l_last_used_block);
END;
/



U4 - P2  - DDL PACKAGE - RECOMPILE

===================[CREATE PACKAGE]==============================
CREATE OR REPLACE PACKAGE emp_pkg IS
    PROCEDURE show_emp(p_empno NUMBER);
END emp_pkg;
/
-----------------------------------------------------------------------
CREATE OR REPLACE PACKAGE BODY emp_pkg IS
    PROCEDURE show_emp(p_empno NUMBER) IS
    BEGIN
        DBMS_OUTPUT.PUT_LINE('Employee no: ' || p_empno);
    END;
END emp_pkg;
/
======================[CHECK THE PACKAGE IS CREATED]================================
SELECT object_name, object_type, status
FROM user_objects
WHERE object_name = 'EMP_PKG';
==============================[recompile package]======================================================

BEGIN
    DBMS_DDL.ALTER_COMPILE('PACKAGE BODY', 'MCA17', 'EMP_PKG');
END;
/
=========================================================================================================================
=====================[create PROCEDURE]=======================================
CREATE OR REPLACE PROCEDURE emp_proc AS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Employee procedure executed successfully!');
END;
/
------------------[EXECUTE PROCEDURE]--------------------
set serveroutput on;
EXEC emp_proc;
---------------------------------------
SELECT object_name, object_type, status
FROM user_objects
WHERE object_name = 'EMP_PROC';
---------------------------[RECOMPILE PROCEDURE]-------------------
BEGIN
    DBMS_DDL.ALTER_COMPILE('PROCEDURE', 'MCA17', 'EMP_PROC');
END;
/





U4 - P3  ------ DDL PACKAGE ( INSERT )


==========================================================================
BEGIN
  DBMS_DDL.ANALYZE_OBJECT('TABLE', 'your_table_name');
  DBMS_DDL.ANALYZE_OBJECT('INDEX', 'your_index_name');
  DBMS_DDL.ANALYZE_OBJECT('CLUSTER', 'your_cluster_name');
END;

==========================================================================

=========================[ANALYZE TABLE]===============================
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'MCA36',       -- your schema
        tabname => 'BOOK_DETAILS', -- table to analyze
        cascade => TRUE            -- also gather stats for indexes
    );
END;
/

=========================[ANALYZE INDEX]==============================
---------------------CREATE INDEX--------------
CREATE INDEX BOOK_DETAILS_IDX
ON BOOK_DETAILS(TITLE);
-----------------------------------------------
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'MCA36',
        tabname => 'BOOK_DETAILS',
        cascade => TRUE  -- also gathers index stats
    );
END;
/

=========================[ANALYZE CLUSTER]============================
BEGIN
    DBMS_STATS.GATHER_TABLE_STATS(
        ownname => 'MCA36',
        tabname => 'BOOK_CLUSTER', 
        cascade => TRUE            
    );
END;
/
--------------------------CREATE CLUSTER-------------------------
CREATE CLUSTER BOOK_CLUSTER (
    BOOK_ID NUMBER,
    AUTHOR_ID NUMBER
)
SIZE 1024;

-----------------------------------
CREATE TABLE BOOK_DETAILS (
    BOOK_ID NUMBER,
    AUTHOR_ID NUMBER,
    TITLE VARCHAR2(100),
    PRICE NUMBER(10,2)
) CLUSTER BOOK_CLUSTER (BOOK_ID, AUTHOR_ID);

=======================================================================
SHOW LAST ANALYZE TIME
----------------------------------------------------------------------
SELECT table_name, num_rows, blocks, last_analyzed
FROM user_tables
WHERE table_name = 'BOOK_DETAILS';





  U4 - P5  - DATABASE FREGMENTATION

CREATE TABLE emp_frag (
    emp_id     NUMBER PRIMARY KEY,
    emp_name   VARCHAR2(50),
    emp_addr   VARCHAR2(4000)
)
TABLESPACE USERS
STORAGE (
    INITIAL 64K
    NEXT 64K
    PCTINCREASE 0
);

INSERT INTO emp_frag VALUES (1, 'Ankesh', 'Delhi');
INSERT INTO emp_frag VALUES (2, 'Ram', 'Mumbai');
INSERT INTO emp_frag VALUES (3, 'Sita', 'Pune');
INSERT INTO emp_frag VALUES (4, 'Jayesh', 'Chennai');
COMMIT;

UPDATE emp_frag
SET emp_addr = RPAD('X', 2900, 'X')
WHERE emp_id = 1;

UPDATE emp_frag
SET emp_addr = RPAD('Y', 2900, 'Y')
WHERE emp_id = 2;

UPDATE emp_frag
SET emp_addr = RPAD('Z', 2900, 'Z')
WHERE emp_id = 3;

COMMIT;

ANALYZE TABLE emp_frag LIST CHAINED ROWS INTO chained_rows;

SELECT owner_name, table_name, head_rowid
FROM chained_rows
WHERE table_name = 'EMP_FRAG';

-----------------------------------------------for remove fregmentation----------------


CREATE TABLE emp_frag_dummy AS SELECT * FROM emp_frag WHERE 1=0;


INSERT INTO emp_frag_dummy
SELECT *
FROM emp_frag
WHERE ROWID IN (SELECT head_rowid FROM chained_rows WHERE table_name='EMP_FRAG');


DELETE FROM emp_frag
WHERE ROWID IN (SELECT head_rowid FROM chained_rows WHERE table_name='EMP_FRAG');


INSERT INTO emp_frag
SELECT * FROM emp_frag_dummy;



TRUNCATE TABLE chained_rows;





U4 -P6   -   Dynamic Sql

agar hume table ka naam, column ka naam, ya condition runtime par change karni ho…
To hum Dynamic SQL use karte hain.

Oracle mein dynamic SQL execute karne ke do tareeke hote hain:

1️⃣ EXECUTE IMMEDIATE (simple aur easy cases ke liye)
2️⃣ DBMS_SQL package (advance cases, unknown columns, dynamic metadata ke liye)



CREATE TABLE emp (
    empno NUMBER,
    ename VARCHAR2(50),
    deptno NUMBER
)
storage (initial 1k next 10k minextents 1 maxextents 5)
;

INSERT INTO emp VALUES (101, 'ANKESH', 10);
INSERT INTO emp VALUES (102, 'JAYESH', 20);
INSERT INTO emp VALUES (103, 'PARTH', 10);
COMMIT;
===============================================================================
SET SERVEROUTPUT ON;

DECLARE
    v_cursor_id   NUMBER;         -- Cursor handle
    v_query       VARCHAR2(200);  -- Dynamic SQL query
    v_empno       NUMBER;         -- Output variable
    v_ename       VARCHAR2(50);   -- Output variable
    v_status      NUMBER;         -- Execution status
BEGIN
    -- Step 1: Build SQL query dynamically
    v_query := 'SELECT empno, ename FROM emp WHERE deptno = :deptno';

    -- Step 2: Open a cursor
    v_cursor_id := DBMS_SQL.OPEN_CURSOR;

    -- Step 3: Parse the SQL statement
    DBMS_SQL.PARSE(v_cursor_id, v_query, DBMS_SQL.NATIVE);

    -- Step 4: Bind the variable
    DBMS_SQL.BIND_VARIABLE(v_cursor_id, ':deptno', 10);

    -- Step 5: Define columns to fetch
    DBMS_SQL.DEFINE_COLUMN(v_cursor_id, 1, v_empno);
    DBMS_SQL.DEFINE_COLUMN(v_cursor_id, 2, v_ename, 50);

    -- Step 6: Execute the statement
    v_status := DBMS_SQL.EXECUTE(v_cursor_id);

    -- Step 7: Fetch and display rows
    LOOP
        EXIT WHEN DBMS_SQL.FETCH_ROWS(v_cursor_id) = 0;
        DBMS_SQL.COLUMN_VALUE(v_cursor_id, 1, v_empno);
        DBMS_SQL.COLUMN_VALUE(v_cursor_id, 2, v_ename);
        DBMS_OUTPUT.PUT_LINE('Emp No: ' || v_empno || ' | Name: ' || v_ename);
    END LOOP;

    -- Step 8: Close cursor
    DBMS_SQL.CLOSE_CURSOR(v_cursor_id);


END;
/
